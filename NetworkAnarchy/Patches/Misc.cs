using ColossalFramework;
using HarmonyLib;
using QCommonLib;
using System;
using System.Diagnostics;
using System.Reflection;
using UnityEngine;

namespace NetworkAnarchy.Patches
{
    class Utils
    {
        /// <summary>
        /// Remove building limiting errors for networks
        /// </summary>
        /// <param name="errors">The errors generated by the vanilla game</param>
        /// <returns>The pruned down errors</returns>
        internal static ToolBase.ToolErrors YeetLimits(ToolBase.ToolErrors errors)
        {
            if (NetworkAnarchy.Anarchy)
            {
                errors &= ~ToolBase.ToolErrors.CanalTooClose;
                errors &= ~ToolBase.ToolErrors.CannotBuildOnWater;
                errors &= ~ToolBase.ToolErrors.HeightTooHigh;
                errors &= ~ToolBase.ToolErrors.ShoreNotFound;
                errors &= ~ToolBase.ToolErrors.SlopeTooSteep;
                errors &= ~ToolBase.ToolErrors.WaterNotFound;
            }
            return errors;
        }

        /// <summary>
        /// Check if this collision check is being run for a tree
        /// </summary>
        /// <returns>Whether or not a tree is colliding</returns>
        //internal static bool IsTreeOverlap()
        //{
        //    StackTrace trace = new StackTrace();
        //    if (trace == null) return false;

        //    for (int i = 2; i < trace.FrameCount; i++)
        //    {
        //        Log.Debug($"AAA01 {i}");
        //        StackFrame frame = trace.GetFrame(i);
        //        if (frame == null) return false;

        //        MethodBase method = frame.GetMethod();
        //        Log.Debug($"AAA02 {i} ({method.DeclaringType.ToString() + "." + method.Name})");
        //        if ("TreeInstance.CheckOverlap" == method.DeclaringType.ToString() + "." + method.Name)
        //        {
        //            Log.Debug($"Tree overlap found!", "[NA67]");
        //            return true;
        //        }
        //    }

        //    return false;
        //}
    }

    /// <summary>
    /// Make ship and airplane paths bulldozeable 
    /// </summary>
    [HarmonyPatch(typeof(DefaultTool), "GetService")]
    public static class DT_GetService
    {
        public static void Postfix(ref ToolBase.RaycastService __result)
        {
            if (QCommon.Scene != QCommon.SceneTypes.Game) return;

            if (Singleton<InfoManager>.instance.CurrentMode == InfoManager.InfoMode.Transport)
            {
                __result.m_itemLayers |= ItemClass.Layer.AirplanePaths | ItemClass.Layer.ShipPaths;
            }
        }
    }

    /// <summary>
    /// Allow ship and airplane paths to be built outside the purchased tiles
    /// Patch deployed by Mods.CrossTheLine
    /// </summary>
    public static class GAM_QuadOutOfArea
    {
        public static bool Prefix(ref bool __result)
        {
            try
            {
                if (!(Singleton<ToolController>.instance.CurrentTool is NetTool)) return true;
                NetTool netTool = (NetTool)Singleton<ToolController>.instance.CurrentTool;
                if (netTool.Prefab == null) return true;
                NetInfo prefab = netTool.Prefab;

                if (prefab.name == "Ship Path" || prefab.name == "Airplane Path")
                {
                    __result = false;
                    return false;
                }
            }
            catch (NullReferenceException e)
            {
                UnityEngine.Debug.Log($"Failed to enable placing transport paths outside purchased tiles\n{e}");
            }
            return true;
        }
    }

    /// <summary>
    /// Override the InfoMode underground view
    /// </summary>
    [HarmonyPatch(typeof(InfoManager), "SetCurrentMode")]
    public static class IM_SetCurrentMode
    {
        public static void Prefix(ref InfoManager.InfoMode mode, InfoManager.SubInfoMode subMode)
        {
            if (NetworkAnarchy.instance == null) return;
            NetworkAnarchy inst = NetworkAnarchy.instance;
            if (!inst.IsActive || !inst.IsNetToolEnabled()) return;
            if (mode != InfoManager.InfoMode.Underground) return;
            if (inst.mode == Modes.Tunnel) return;

            if (inst.mode == Modes.Ground)
            {
                mode = InfoManager.InfoMode.None;
            }
            else if (inst.mode == Modes.Elevated || inst.mode == Modes.Bridge || inst.mode == Modes.Normal)
            {
                if (inst.elevation > -8)
                {
                    mode = InfoManager.InfoMode.None;
                }
            }

            //Log.Debug($"IM_SetCurrentMode: \"{prefab.Prefab.name}\" {inst.elevation} ({inst.mode},{prefab.Mode})");
        }
    }
}
